# Kubernetes Job to automatically setup PeerDB CDC mirror
# This job runs after PeerDB is deployed and creates:
# - PostgreSQL peer (source)
# - ClickHouse peer (destination)
# - Mirror: pg-to-ch-mirror (users, orders, events tables)

apiVersion: v1
kind: ConfigMap
metadata:
  name: peerdb-setup-script
  namespace: peerdb
data:
  setup-mirror.py: |
    #!/usr/bin/env python3
    """PeerDB Mirror Auto-Setup Script"""

    import os
    import sys
    import time
    import json
    import base64
    import subprocess
    import requests
    from typing import Optional

    class Colors:
        BLUE = '\033[0;34m'
        GREEN = '\033[0;32m'
        YELLOW = '\033[1;33m'
        RED = '\033[0;31m'
        NC = '\033[0m'

    def print_header(msg: str):
        print(f"\n{Colors.BLUE}{'='*60}{Colors.NC}")
        print(f"{Colors.BLUE}{msg}{Colors.NC}")
        print(f"{Colors.BLUE}{'='*60}{Colors.NC}\n")

    def print_success(msg: str):
        print(f"{Colors.GREEN}✅ {msg}{Colors.NC}")

    def print_error(msg: str):
        print(f"{Colors.RED}❌ {msg}{Colors.NC}")

    def print_info(msg: str):
        print(f"{Colors.YELLOW}ℹ️  {msg}{Colors.NC}")

    def get_kubernetes_secret(namespace: str, secret_name: str, key: str) -> Optional[str]:
        """Get secret from Kubernetes."""
        try:
            cmd = [
                'kubectl', 'get', 'secret', '-n', namespace,
                secret_name, '-o', f'jsonpath={{.data.{key}}}'
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            if result.stdout:
                return base64.b64decode(result.stdout).decode('utf-8')
            return None
        except Exception as e:
            print_error(f"Failed to get secret: {e}")
            return None

    def wait_for_peerdb(base_url: str, max_retries: int = 30):
        """Wait for PeerDB to be ready."""
        print_info("Waiting for PeerDB to be ready...")
        for i in range(max_retries):
            try:
                response = requests.get(f"{base_url}/api/health", timeout=5)
                if response.status_code == 200:
                    print_success("PeerDB is ready!")
                    return True
            except Exception:
                pass
            print(f"  Attempt {i+1}/{max_retries}... waiting 10s")
            time.sleep(10)
        print_error("PeerDB did not become ready")
        return False

    def create_postgres_peer(base_url: str, pg_password: str) -> bool:
        """Create PostgreSQL peer."""
        print_info("Creating PostgreSQL peer...")
        peer_config = {
            "name": "postgres-source",
            "type": "POSTGRES",
            "config": {
                "host": "postgres-cluster-rw.cloudnative-pg.svc.cluster.local",
                "port": 5432,
                "user": "app_user",
                "password": pg_password,
                "database": "app_db"
            }
        }
        try:
            response = requests.post(
                f"{base_url}/api/v1/peers",
                json=peer_config,
                headers={"Content-Type": "application/json"},
                timeout=30
            )
            if response.status_code in [200, 201, 409]:
                print_success("PostgreSQL peer created")
                return True
            print_error(f"Failed: {response.status_code} - {response.text}")
            return False
        except Exception as e:
            print_error(f"Exception: {e}")
            return False

    def create_clickhouse_peer(base_url: str) -> bool:
        """Create ClickHouse peer."""
        print_info("Creating ClickHouse peer...")
        peer_config = {
            "name": "clickhouse-destination",
            "type": "CLICKHOUSE",
            "config": {
                "host": "chi-clickhouse-cluster-clickhouse-0-0.clickhouse.svc.cluster.local",
                "port": 9000,
                "user": "admin",
                "password": "admin123",
                "database": "default"
            }
        }
        try:
            response = requests.post(
                f"{base_url}/api/v1/peers",
                json=peer_config,
                headers={"Content-Type": "application/json"},
                timeout=30
            )
            if response.status_code in [200, 201, 409]:
                print_success("ClickHouse peer created")
                return True
            print_error(f"Failed: {response.status_code} - {response.text}")
            return False
        except Exception as e:
            print_error(f"Exception: {e}")
            return False

    def create_mirror(base_url: str) -> bool:
        """Create CDC mirror."""
        print_info("Creating CDC mirror (PG → CH)...")
        mirror_config = {
            "flowJobName": "pg-to-ch-mirror",
            "source": {
                "peerName": "postgres-source",
                "schemaName": "public",
                "tableNames": ["users", "orders", "events"]
            },
            "destination": {
                "peerName": "clickhouse-destination",
                "schemaName": "default"
            },
            "syncMode": "CDC",
            "cdcConfig": {
                "snapshotNumRowsPerPartition": 10000,
                "snapshotMaxParallelWorkers": 4,
                "snapshotNumTablesInParallel": 1,
                "doInitialSnapshot": True,
                "replicationSlotName": "peerdb_slot_pg_to_ch"
            }
        }
        try:
            response = requests.post(
                f"{base_url}/api/v1/mirrors",
                json=mirror_config,
                headers={"Content-Type": "application/json"},
                timeout=30
            )
            if response.status_code in [200, 201, 409]:
                print_success("Mirror created: pg-to-ch-mirror")
                return True
            print_error(f"Failed: {response.status_code} - {response.text}")
            return False
        except Exception as e:
            print_error(f"Exception: {e}")
            return False

    def main():
        print_header("PeerDB Mirror Auto-Setup")
        peerdb_url = "http://peerdb.peerdb.svc.cluster.local:3000"

        if not wait_for_peerdb(peerdb_url):
            sys.exit(1)

        pg_password = get_kubernetes_secret('cloudnative-pg', 'postgres-cluster-app', 'password')
        if not pg_password:
            sys.exit(1)

        if not create_postgres_peer(peerdb_url, pg_password):
            sys.exit(1)

        if not create_clickhouse_peer(peerdb_url):
            sys.exit(1)

        time.sleep(5)

        if not create_mirror(peerdb_url):
            sys.exit(1)

        print_header("Setup Complete!")
        print("CDC Mirror: postgres-source → clickhouse-destination")
        print("Tables: users, orders, events")

    if __name__ == "__main__":
        main()

---
apiVersion: batch/v1
kind: Job
metadata:
  name: peerdb-setup-mirror
  namespace: peerdb
  labels:
    app: peerdb-setup
spec:
  # Keep job history for debugging
  ttlSecondsAfterFinished: 86400  # 24 hours
  backoffLimit: 3

  template:
    metadata:
      labels:
        app: peerdb-setup
    spec:
      restartPolicy: OnFailure

      # Service account with permissions to read secrets
      serviceAccountName: peerdb-setup

      containers:
        - name: setup-mirror
          image: python:3.11-slim
          command: ["/bin/bash", "-c"]
          args:
            - |
              set -e
              echo "Installing dependencies..."
              pip install --quiet requests
              apt-get update -qq && apt-get install -y -qq curl kubectl

              echo "Waiting for PostgreSQL to be ready..."
              until kubectl get pods -n cloudnative-pg -l cnpg.io/cluster=postgres-cluster | grep Running; do
                sleep 10
              done

              echo "Waiting for ClickHouse to be ready..."
              until kubectl get pods -n clickhouse -l app=clickhouse | grep Running; do
                sleep 10
              done

              echo "Waiting for PeerDB to be ready..."
              until kubectl get pods -n peerdb -l app=peerdb | grep Running; do
                sleep 10
              done

              echo "Running setup script..."
              python3 /scripts/setup-mirror.py

          volumeMounts:
            - name: script
              mountPath: /scripts

          env:
            - name: PYTHONUNBUFFERED
              value: "1"

      volumes:
        - name: script
          configMap:
            name: peerdb-setup-script
            defaultMode: 0755

---
# ServiceAccount with permissions to read secrets
apiVersion: v1
kind: ServiceAccount
metadata:
  name: peerdb-setup
  namespace: peerdb

---
# Role to read secrets in cloudnative-pg namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: peerdb-setup-read-secrets
  namespace: cloudnative-pg
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list"]

---
# RoleBinding for cloudnative-pg namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: peerdb-setup-read-secrets
  namespace: cloudnative-pg
subjects:
  - kind: ServiceAccount
    name: peerdb-setup
    namespace: peerdb
roleRef:
  kind: Role
  name: peerdb-setup-read-secrets
  apiGroup: rbac.authorization.k8s.io

---
# Role to read pods in all namespaces (for readiness check)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: peerdb-setup-read-pods
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]

---
# ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: peerdb-setup-read-pods
subjects:
  - kind: ServiceAccount
    name: peerdb-setup
    namespace: peerdb
roleRef:
  kind: ClusterRole
  name: peerdb-setup-read-pods
  apiGroup: rbac.authorization.k8s.io
