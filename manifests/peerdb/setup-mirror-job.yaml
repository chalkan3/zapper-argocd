# Kubernetes Job to automatically setup PeerDB CDC mirror
# This job runs after PeerDB is deployed and creates:
# - PostgreSQL peer (source)
# - ClickHouse peer (destination)
# - Mirror: pg-to-ch-mirror (users, orders, events tables)

apiVersion: v1
kind: ConfigMap
metadata:
  name: peerdb-setup-script
  namespace: peerdb
data:
  setup-mirror.py: |
    #!/usr/bin/env python3
    """PeerDB Mirror Auto-Setup Script"""

    import os
    import sys
    import time
    import json
    import base64
    import subprocess
    import requests
    from typing import Optional

    class Colors:
        BLUE = '\033[0;34m'
        GREEN = '\033[0;32m'
        YELLOW = '\033[1;33m'
        RED = '\033[0;31m'
        NC = '\033[0m'

    def print_header(msg: str):
        print(f"\n{Colors.BLUE}{'='*60}{Colors.NC}")
        print(f"{Colors.BLUE}{msg}{Colors.NC}")
        print(f"{Colors.BLUE}{'='*60}{Colors.NC}\n")

    def print_success(msg: str):
        print(f"{Colors.GREEN}✅ {msg}{Colors.NC}")

    def print_error(msg: str):
        print(f"{Colors.RED}❌ {msg}{Colors.NC}")

    def print_info(msg: str):
        print(f"{Colors.YELLOW}ℹ️  {msg}{Colors.NC}")

    def get_kubernetes_secret(namespace: str, secret_name: str, key: str) -> Optional[str]:
        """Get secret from Kubernetes."""
        try:
            cmd = [
                'kubectl', 'get', 'secret', '-n', namespace,
                secret_name, '-o', f'jsonpath={{.data.{key}}}'
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            if result.stdout:
                return base64.b64decode(result.stdout).decode('utf-8')
            return None
        except Exception as e:
            print_error(f"Failed to get secret: {e}")
            return None

    def wait_for_peerdb(base_url: str, max_retries: int = 60):
        """Wait for PeerDB API to be ready."""
        print_info("Waiting for PeerDB API to be ready...")
        for i in range(max_retries):
            try:
                # Check if the API endpoint is responding
                response = requests.get(f"{base_url}/api/v1/peers", timeout=5)
                # If we get 200 or even 404, the API is up
                if response.status_code in [200, 404, 405]:
                    print_success("PeerDB API is ready!")
                    # Give it a few more seconds to fully initialize
                    time.sleep(10)
                    return True
            except requests.exceptions.ConnectionError:
                pass
            except requests.exceptions.Timeout:
                pass
            except Exception as e:
                pass
            if (i + 1) % 6 == 0:  # Print every 30 seconds
                print(f"  Attempt {i+1}/{max_retries}... waiting 5s")
            time.sleep(5)
        print_error("PeerDB API did not become ready")
        return False

    def create_postgres_peer(base_url: str, pg_password: str) -> bool:
        """Create PostgreSQL peer."""
        print_info("Creating PostgreSQL peer...")
        # Correct format based on PeerDB API docs
        payload = {
            "peer": {
                "name": "postgres-source",
                "type": 3,  # POSTGRES type (not 1)
                "postgres_config": {
                    "host": "postgres-cluster-rw.cloudnative-pg.svc.cluster.local",
                    "port": 5432,
                    "user": "app_user",
                    "password": pg_password,
                    "database": "app_db"
                }
            },
            "allow_update": False
        }
        try:
            response = requests.post(
                f"{base_url}/api/v1/peers/create",
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=30
            )
            if response.status_code in [200, 201, 409]:
                print_success("PostgreSQL peer created")
                return True
            print_error(f"Failed: {response.status_code} - {response.text}")
            # Try to continue anyway if already exists
            return response.status_code == 409
        except Exception as e:
            print_error(f"Exception: {e}")
            return False

    def create_clickhouse_peer(base_url: str) -> bool:
        """Create ClickHouse peer."""
        print_info("Creating ClickHouse peer...")
        # Correct format based on PeerDB API docs
        payload = {
            "peer": {
                "name": "clickhouse-destination",
                "type": 8,  # CLICKHOUSE type (not 2)
                "clickhouse_config": {
                    "host": "chi-clickhouse-cluster-main-cluster-0-0.clickhouse.svc.cluster.local",
                    "port": 9000,
                    "user": "admin",
                    "password": "admin123",
                    "database": "default",
                    "disable_tls": True
                }
            },
            "allow_update": False
        }
        try:
            response = requests.post(
                f"{base_url}/api/v1/peers/create",
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=30
            )
            if response.status_code in [200, 201, 409]:
                print_success("ClickHouse peer created")
                return True
            print_error(f"Failed: {response.status_code} - {response.text}")
            # Try to continue anyway if already exists
            return response.status_code == 409
        except Exception as e:
            print_error(f"Exception: {e}")
            return False

    def create_mirror(base_url: str) -> bool:
        """Create CDC mirror."""
        print_info("Creating CDC mirror (PG → CH)...")
        # Corrected format based on PeerDB API documentation
        # The API expects connection_configs wrapper
        payload = {
            "connection_configs": {
                "flow_job_name": "pg_to_ch_mirror",
                "source_name": "postgres-source",
                "destination_name": "clickhouse-destination",
                "table_mappings": [
                    {
                        "source_table_identifier": "public.users",
                        "destination_table_identifier": "default.users"
                    },
                    {
                        "source_table_identifier": "public.orders",
                        "destination_table_identifier": "default.orders"
                    },
                    {
                        "source_table_identifier": "public.events",
                        "destination_table_identifier": "default.events"
                    }
                ],
                "do_initial_snapshot": True,
                "max_batch_size": 1000000,
                "idle_timeout_seconds": 60
            }
        }

        # First verify peers exist
        print_info("Verifying peers exist...")
        try:
            peers_response = requests.get(
                f"{base_url}/api/v1/peers",
                timeout=10
            )
            if peers_response.status_code == 200:
                print_success(f"Found {len(peers_response.json())} peer(s)")
            else:
                print_info(f"Peer check returned: {peers_response.status_code}")
        except Exception as e:
            print_info(f"Could not verify peers: {e}")

        # Create the mirror
        try:
            response = requests.post(
                f"{base_url}/api/v1/flows/cdc/create",
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=120
            )
            if response.status_code in [200, 201, 409]:
                print_success("Mirror created: pg_to_ch_mirror")
                return True
            print_error(f"Failed: {response.status_code} - {response.text}")
            return False
        except Exception as e:
            print_error(f"Exception: {e}")
            return False

    def main():
        print_header("PeerDB Mirror Auto-Setup")
        peerdb_url = "http://peerdb-server.peerdb.svc.cluster.local:9900"

        if not wait_for_peerdb(peerdb_url):
            sys.exit(1)

        pg_password = get_kubernetes_secret('cloudnative-pg', 'postgres-cluster-app', 'password')
        if not pg_password:
            sys.exit(1)

        if not create_postgres_peer(peerdb_url, pg_password):
            sys.exit(1)

        if not create_clickhouse_peer(peerdb_url):
            sys.exit(1)

        time.sleep(5)

        if not create_mirror(peerdb_url):
            sys.exit(1)

        print_header("Setup Complete!")
        print("CDC Mirror: postgres-source → clickhouse-destination")
        print("Tables: users, orders, events")

    if __name__ == "__main__":
        main()

---
apiVersion: batch/v1
kind: Job
metadata:
  name: peerdb-setup-mirror
  namespace: peerdb
  labels:
    app: peerdb-setup
spec:
  # Keep job history for debugging
  ttlSecondsAfterFinished: 86400  # 24 hours
  backoffLimit: 3

  template:
    metadata:
      labels:
        app: peerdb-setup
    spec:
      restartPolicy: OnFailure

      # Service account with permissions to read secrets
      serviceAccountName: peerdb-setup

      containers:
        - name: setup-mirror
          image: python:3.11-slim
          command: ["/bin/bash", "-c"]
          args:
            - |
              set -e
              echo "Installing dependencies..."
              pip install --quiet requests
              apt-get update -qq && apt-get install -y -qq curl kubectl

              echo "Waiting for PostgreSQL to be ready..."
              until kubectl get pods -n cloudnative-pg -l cnpg.io/cluster=postgres-cluster | grep Running; do
                sleep 10
              done

              echo "Waiting for ClickHouse to be ready..."
              until kubectl get pods -n clickhouse -l clickhouse.altinity.com/chi=clickhouse-cluster | grep Running; do
                sleep 10
              done

              echo "Waiting for PeerDB to be ready..."
              until kubectl get pods -n peerdb -l app=peerdb | grep Running; do
                sleep 10
              done

              echo "Running setup script..."
              python3 /scripts/setup-mirror.py

          volumeMounts:
            - name: script
              mountPath: /scripts

          env:
            - name: PYTHONUNBUFFERED
              value: "1"

      volumes:
        - name: script
          configMap:
            name: peerdb-setup-script
            defaultMode: 0755

---
# ServiceAccount with permissions to read secrets
apiVersion: v1
kind: ServiceAccount
metadata:
  name: peerdb-setup
  namespace: peerdb

---
# Role to read secrets in cloudnative-pg namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: peerdb-setup-read-secrets
  namespace: cloudnative-pg
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list"]

---
# RoleBinding for cloudnative-pg namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: peerdb-setup-read-secrets
  namespace: cloudnative-pg
subjects:
  - kind: ServiceAccount
    name: peerdb-setup
    namespace: peerdb
roleRef:
  kind: Role
  name: peerdb-setup-read-secrets
  apiGroup: rbac.authorization.k8s.io

---
# Role to read pods in all namespaces (for readiness check)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: peerdb-setup-read-pods
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]

---
# ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: peerdb-setup-read-pods
subjects:
  - kind: ServiceAccount
    name: peerdb-setup
    namespace: peerdb
roleRef:
  kind: ClusterRole
  name: peerdb-setup-read-pods
  apiGroup: rbac.authorization.k8s.io
